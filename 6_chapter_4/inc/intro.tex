%general idea - productivity through digitalization and code
Digitalization has been identified as one of the most promising tools to increase productivity in a vast range of disciplines.\cite{Tuomi2018}
Over the last four decades, computational techniques have also become increasingly relevant in chemistry, and many methods are now routinely used in academia and industry to e.g. predict the physicochemical properties of molecules, their 3D conformation and interactions with other molecules, or their chemical reactivity. A prominent application of computational chemistry is the highly interdisciplinary field of drug discovery, where computational approaches are employed in all stages of the development process.\cite{Chodera2011, Hansen2014, Abel2017, Cournia2017, Cournia2020, Meier2021}

%% Diversification of coding skill 
With the growing application of computational chemistry in industry, also the fraction of scientists that need to read or write software code increases. Typical tasks do not require writing highly optimized code in low-level languages such as Java\cite{Gosling2000}, Fortran\cite{Backus1957}, or C++\cite{Stroustrup1995}. As a consequence, more advanced concepts such as memory management, parallel programming, or advanced programming paradigms are not always considered during code development, possibly leading to problems later on. In most projects, it is a balance between long-term sustainable code and so-called technical debt\cite{Alfayez2018} to obtain results on the short term. This issue has led to the development of convenient-to-use scripting languages and APIs, which can be used to swiftly implement solutions to complex problems with minimal technical debt. By doing this, time is freed to focus on problems requiring specialized knowledge.\cite{Ayer2014} The scripting language with the highest impact in science nowadays is Python. Already in 2011, Python was declared the \textit{de facto} standard language in natural sciences and engineering, and from 2017 to today (2021), Python has remained the highest-ranked language in the \textit{IEEE Spectrum} journal. This ranking reflects the user interests measured by the internet community Stack Overflow, data available on GitHub, and IEEE Articles. \cite{Millman2011, Vanderwalt2011, Cass2017, Cass2018, Cass2019, Cass2020, Cass2021} 
%
Core features identified by Oliphant\cite{Oliphant2007} that make Python attractive to a widespread audience are: 
\begin{itemize}
    \item Intuitive syntax that is easy to read and learn, and thus allows rapid prototyping.
    \item Straightforward integration with other programming languages (especially C/C++\cite{Stroustrup1995}, enabled by tools like pybinds\cite{Wenzel2011}, Boost Python\cite{Koranne2011}, SWIG\cite{Beazley1996}, Cython\cite{Behnel2011}, or Numba\cite{Lam2015}).
    \item Large community supporting high-quality packages (e.g., NumPy\cite{Vanderwalt2011}, SciPy\cite{Virtanen2020}, Matplotlib\cite{Hunter2007}, Pandas\cite{Mckinney2010}, and Jupyter\cite{Kluyver2016}).
    \item High-quality tools for environment and package management (e.g. pip\cite{Pypi2021} and conda\cite{Anaconda2020}).
    \item Platform independence that enables development on different operating systems and computer architectures.
\end{itemize}

%APIs in Python -> Efficiency as API
Despite the boom of Python, one downside of this programming language is its limited computational performance in a native form, which is related to the dynamic typing concept. To address the efficiency issues of native Python code, many different solutions have been developed. One solution is to translate the Python code during run-time (just-in-time-compiling) into C code\cite{Kernighan2006} or directly into machine code\cite{Lattner2008}. Tools making this solution accessible are for example Cython\cite{Behnel2011} or Numba\cite{Lam2015}. 
Prominent packages like SciPy\cite{Vanderwalt2011}, NumPy\cite{Virtanen2020}, or Pandas\cite{Mckinney2010} follow a reverse approach and use Python as a wrapper to bind C or Fortran code. In this case, Python merely 'steers' the code execution and the user only interacts with the Python layer.\cite{Oliphant2007} 
Tools like pybind11\cite{Wenzel2017} or Boost Python\cite{Koranne2011} make this approach easy to implement and allow rapid construction of Python APIs. 
Many packages in computational chemistry make use of this concept. Examples are RDKit\cite{Landrum2021}, PyMol\cite{Delano2020}, PySCF\cite{Sun2018}, pyOpenMS\cite{Roest2014}, BioPython\cite{Cock2009}, and Pybel\cite{O'Boyle2008}. The most popular MD packages follow this trend and offer Python APIs. GROMACS \cite{Berendsen1995, Lindahl2001, Abraham2015} and AMBER\cite{Weiner1981, Pearlman1995, Case2005} provide for this purpose the packages gmxapi\cite{Irrgang2018} and ParmEd\cite{Shirts2017}, respectively. OpenMM\cite{Friedrichs2009, Eastman2010, Eastman2017} and LAMMPS,\cite{plimpton1995, Thompson2022} on the other hand, include Python APIs natively.\cite{Talirz2021}
%Multiple packages from our group follow this concept, for example the vsCNN repository for hierarchical clustering. \cite{Weiss2021}
Here, we introduce a Python API for the GROMOS software package \cite{Schmid2012} called PyGromosTools.\cite{Lehner2021} This API is a starting point for further development that may ultimately allow access to the entire functionality of GROMOS as well as GROMOS++ \cite{Eichenberger2011} from Python. Currently, PyGromosTools already provides access to the simulation trajectories and to a selection of GROMOS features, together with job queueing for high perfomance computing (HPC) clusters, and data analysis functionality. This chapter presents our rationale behind the design of PyGromosTools and shows examples of how the API can be used.



\FloatBarrier