

Ensembler is implemented in Python3\cite{VanRossum2009} and available on GitHub\cite{Github2020}  (\textit{\hyperlink{https://github.com/rinikerlab/Ensembler}{rinikerlab/Ensembler}}). 
The repository is based on the template of the MolSSI cookie-cutter\cite{Naden2018} and comprises a code folder, an example folder for tutorials, example models contained in the provided Jupyter notebooks,\cite{Kluyver2016} an automatic pytest suite,\cite{Krekel2004} and the automatically generated sphinx \cite{Brandl2008} documentation. 
The code is continuously integrated via GitHub Actions,\cite{githhubAction20} providing information about code quality, test correctness, test coverage, and generation of an up-to-date documentation. 
Ensembler uses only open-source packages like the SciPy library\cite{Virtanen2020, VanDerWalt2011, Meurer2017, Mckinney2010, Hunter2007} and Jupyter notebooks.\cite{Kluyver2016} 
In the following, a user and a developer perspective are provided for the code structure. 

%-------------------------------------------------------
\subsection{User level}
%-------------------------------------------------------
 A simulation model in Ensembler consists of a potential class, a sampler class, and a system class wrapping the potential and the sampler (Figure~\ref{fig:UML-Diagramm}), and provides control over the simulation approach. 
Additionally, multiple condition classes can be added that directly influence the simulation (e.g. periodic boundary condition\cite{Cheatham1995, Leach2001} or  thermostatting\cite{Andersen1980}). 
After the construction of the system, the simulation can be started directly with the \textit{simulate} function. 
The resulting trajectory is in the form of a Pandas data frame.\cite{Mckinney2010} The trajectory is thus easily compatible with other packages like NumPy\cite{VanDerWalt2011} or scikit-learn\cite{scikit-learn} and can be stored in different formats, e.g. as .csv or .hf5 file. The system itself can be stored directly via the save function using serialization of the object with the Python package pickle.
In most cases, only a few additional lines are needed to go from simple simulation technique to more advanced one, as shown below. 

%-------------------------------------------------------
\subsection{Developer level}
%-------------------------------------------------------
The code of Ensembler is built on five interface-like base classes that allow extensive use of the inheritance concept and polymorphism \cite{Stroustrup1995} throughout the package.
These fundamental classes are \textit{potential}, \textit{sampler}, \textit{condition}, \textit{system}, and \textit{ensemble} (Figure \ref{fig:UML-Diagramm}), which can be grouped into three layers.
\textit{Potential}, \textit{sampler}, and \textit{condition classes} form the primary layer, providing different techniques to be used as components in a simulation. 
\textit{Potential classes} provide the potential-energy functions in a symbolic form using SymPy,\cite{Meurer2017} enabling automatic on-the-fly derivation and simplification of the potential-energy function. 
\textit{Sampler classes} are used to explore the potential-energy function (e.g. conjugate gradient,\cite{Hestenes1952} Metropolis MC,\cite{Hastings1970} or leap-frog\cite{VanGunsteren1988} integration). A new method can easily be implemented by inheriting from the \textit{sampler class} and overwriting a single function called \textit{step}. 
Finally, \textit{condition classes} provide additional functionalities such as thermostatting\cite{Andersen1980} and periodic boundary conditions\cite{Cheatham1995, Leach2001}). New techniques can be implemented by inheriting the base \textit{condition class} and overwriting the function \textit{apply}.
In the second layer, the first-layer components are wrapped into one \textit{system class} that executes the simulation(s) and manages the input and output. 
An optional higher-order layer is available in form of the \textit{ensemble class}, which allows the user to perform simulations with replica exchange.\cite{Sugita1999, Sugita2000, Yamauchi2017, Sidler2016a}
If additional parameters are needed in a newly designed class, the constructor of the new child class can be adapted but must call the parent constructor.
